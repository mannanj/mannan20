#!/bin/bash

if [ -n "$IN_POST_COMMIT_HOOK" ]; then
  exit 0
fi

export IN_POST_COMMIT_HOOK=1

REPO_URL="https://github.com/mannanj/mannan20"
OUTPUT_FILE="public/data/dev-commits.json"
METADATA_FILE="public/data/metadata.json"
TASKS_INPUT="tasks.md"
TASKS_OUTPUT="public/data/tasks.json"

mkdir -p "$(dirname "$OUTPUT_FILE")"

node -e "
const { execSync } = require('child_process');

const output = execSync(\`git log -100 --format='%H|||%h|||%s|||%b|||%an|||%aI|||---END---'\`, { encoding: 'utf-8', shell: '/bin/bash' });
const commits = [];
const entries = output.split('|||---END---\n').filter(e => e.trim());

entries.forEach(entry => {
  const parts = entry.split('|||');
  if (parts.length >= 6) {
    commits.push({
      fullHash: parts[0].trim(),
      hash: parts[1].trim(),
      subject: parts[2].trim(),
      body: parts[3].trim(),
      author: parts[4].trim(),
      date: parts[5].trim(),
      url: '${REPO_URL}/commit/' + parts[0].trim()
    });
  }
});

console.log(JSON.stringify(commits, null, 2));
" > "$OUTPUT_FILE"

node -e "
const { execSync } = require('child_process');
const latestDate = execSync('git log -1 --format=%aI', { encoding: 'utf-8', shell: '/bin/bash' }).trim();
console.log(JSON.stringify({ lastUpdated: latestDate }, null, 2));
" > "$METADATA_FILE"

if [ -f "$TASKS_INPUT" ]; then
  node -e "
const fs = require('fs');
const { execSync } = require('child_process');

const tasksMarkdown = fs.readFileSync('${TASKS_INPUT}', 'utf8');

function findTaskCompletionCommit(taskNum, taskTitle) {
  try {
    const logOutput = execSync(
      \`git log --all --format='%H|||%h|||%s|||%aI|||---END---' --follow -p -- ${TASKS_INPUT}\`,
      { encoding: 'utf-8', shell: '/bin/bash' }
    );

    const commitPattern = /^commit ([a-f0-9]{40})/gm;
    const commits = logOutput.split('|||---END---\\n').filter(e => e.trim());

    for (const commitBlock of commits) {
      const parts = commitBlock.split('|||');
      if (parts.length < 4) continue;

      const hashMatch = parts[0].match(/([a-f0-9]{40})$/);
      const fullHash = hashMatch ? hashMatch[1] : parts[0].trim();
      const shortHash = parts[1].trim();
      const subject = parts[2].trim();
      const date = parts[3].split('\\n')[0].trim();

      const diffMatch = commitBlock.match(/### Task (\d+): (.+?)\\n([\\s\\S]*?)(?=###|diff|$)/g);
      if (!diffMatch) continue;

      for (const taskBlock of diffMatch) {
        const taskMatch = taskBlock.match(/### Task (\d+): (.+?)\\n([\\s\\S]*)/);
        if (!taskMatch) continue;

        const blockTaskNum = taskMatch[1];
        if (blockTaskNum !== taskNum) continue;

        const content = taskMatch[3];
        const allCheckboxes = content.match(/- \\[([x ])\\]/g) || [];
        const checkedCount = allCheckboxes.filter(cb => cb.includes('x')).length;

        if (checkedCount === allCheckboxes.length && allCheckboxes.length > 0) {
          const commitMessageMatch = subject.match(/\\[Task[- ]?${taskNum}\\]/i);

          return {
            hash: shortHash,
            fullHash: fullHash,
            subject: subject,
            date: date,
            url: '${REPO_URL}/commit/' + fullHash
          };
        }
      }
    }

    const commitMsgCheck = execSync(
      \`git log --all --format='%H|||%h|||%s|||%aI' --grep='\\[Task[- ]?${taskNum}\\]' -i\`,
      { encoding: 'utf-8', shell: '/bin/bash' }
    ).trim();

    if (commitMsgCheck) {
      const lines = commitMsgCheck.split('\\n');
      const latest = lines[0];
      const parts = latest.split('|||');
      if (parts.length >= 4) {
        return {
          hash: parts[1].trim(),
          fullHash: parts[0].trim(),
          subject: parts[2].trim(),
          date: parts[3].trim(),
          url: '${REPO_URL}/commit/' + parts[0].trim()
        };
      }
    }
  } catch (error) {
    return null;
  }

  return null;
}

const tasks = [];
const taskRegex = /### Task (\\d+): (.+?)\\n([\\s\\S]*?)(?=###|$)/g;
let taskMatch;

while ((taskMatch = taskRegex.exec(tasksMarkdown)) !== null) {
  const taskNum = taskMatch[1];
  const taskTitle = taskMatch[2].trim();
  const taskContent = taskMatch[3];

  const subtasks = [];
  const subtaskRegex = /- \\[([x ])\\] (.+?)$/gm;
  let subtaskMatch;

  while ((subtaskMatch = subtaskRegex.exec(taskContent)) !== null) {
    const completed = subtaskMatch[1] === 'x';
    const description = subtaskMatch[2].trim();

    if (!description.startsWith('Location:')) {
      subtasks.push({
        description,
        completed
      });
    }
  }

  const locationMatch = taskContent.match(/- Location: (.+)/);
  const location = locationMatch ? locationMatch[1].trim() : '';

  const allCompleted = subtasks.length > 0 && subtasks.every(st => st.completed);
  const status = allCompleted ? 'completed' : 'pending';

  const task = {
    id: \`task-\${taskNum}\`,
    title: taskTitle,
    status,
    subtasks,
    location
  };

  if (status === 'completed') {
    const commitInfo = findTaskCompletionCommit(taskNum, taskTitle);
    if (commitInfo) {
      task.completedDate = commitInfo.date;
      task.completedCommit = commitInfo;
    }
  }

  tasks.push(task);
}

console.log(JSON.stringify(tasks, null, 2));
" > "$TASKS_OUTPUT"
fi

if ! git diff --quiet "$OUTPUT_FILE" "$METADATA_FILE" "$TASKS_OUTPUT"; then
  git add "$OUTPUT_FILE" "$METADATA_FILE" "$TASKS_OUTPUT"
  git commit -m "Update dev data files" --no-verify
fi

exit 0
