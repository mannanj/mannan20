#!/bin/bash

if [ -n "$IN_POST_COMMIT_HOOK" ]; then
  exit 0
fi

export IN_POST_COMMIT_HOOK=1

REPO_URL="https://github.com/mannanj/mannan20"
OUTPUT_FILE="public/data/dev-commits.json"
METADATA_FILE="public/data/metadata.json"
TASKS_INPUT="tasks.md"
TASKS_OUTPUT="public/data/tasks.json"

mkdir -p "$(dirname "$OUTPUT_FILE")"

node -e "
const { execSync } = require('child_process');

const output = execSync(\`git log -100 --format='%H|||%h|||%s|||%b|||%an|||%aI|||---END---'\`, { encoding: 'utf-8', shell: '/bin/bash' });
const commits = [];
const entries = output.split('|||---END---\n').filter(e => e.trim());

entries.forEach(entry => {
  const parts = entry.split('|||');
  if (parts.length >= 6) {
    commits.push({
      fullHash: parts[0].trim(),
      hash: parts[1].trim(),
      subject: parts[2].trim(),
      body: parts[3].trim(),
      author: parts[4].trim(),
      date: parts[5].trim(),
      url: '${REPO_URL}/commit/' + parts[0].trim()
    });
  }
});

console.log(JSON.stringify(commits, null, 2));
" > "$OUTPUT_FILE"

node -e "
const { execSync } = require('child_process');
const latestDate = execSync('git log -1 --format=%aI', { encoding: 'utf-8', shell: '/bin/bash' }).trim();
console.log(JSON.stringify({ lastUpdated: latestDate }, null, 2));
" > "$METADATA_FILE"

if [ -f "$TASKS_INPUT" ]; then
  node -e "
const fs = require('fs');
const { execSync } = require('child_process');

const tasksMarkdown = fs.readFileSync('${TASKS_INPUT}', 'utf8');

function findTaskCompletionCommit(taskNum, taskTitle) {
  try {
    let commitMsgCheck = execSync(
      \`git log --format='%H|||%h|||%s|||%aI' --grep='\\[Task-${taskNum}\\]' -i -1\`,
      { encoding: 'utf-8', shell: '/bin/bash' }
    ).trim();

    if (!commitMsgCheck) {
      commitMsgCheck = execSync(
        \`git log --format='%H|||%h|||%s|||%aI' --grep='\\[Task ${taskNum}\\]' -i -1\`,
        { encoding: 'utf-8', shell: '/bin/bash' }
      ).trim();
    }

    if (commitMsgCheck) {
      const parts = commitMsgCheck.split('|||');
      if (parts.length >= 4) {
        return {
          hash: parts[1].trim(),
          fullHash: parts[0].trim(),
          subject: parts[2].trim(),
          date: parts[3].trim(),
          url: '${REPO_URL}/commit/' + parts[0].trim()
        };
      }
    }
  } catch (error) {
    return null;
  }

  return null;
}

const tasks = [];
const taskRegex = /### Task (\\d+): (.+?)\\n([\\s\\S]*?)(?=###|$)/g;
let taskMatch;

while ((taskMatch = taskRegex.exec(tasksMarkdown)) !== null) {
  const taskNum = taskMatch[1];
  const taskTitle = taskMatch[2].trim();
  const taskContent = taskMatch[3];

  const subtasks = [];
  const subtaskRegex = /- \\[([x ])\\] (.+?)$/gm;
  let subtaskMatch;

  while ((subtaskMatch = subtaskRegex.exec(taskContent)) !== null) {
    const completed = subtaskMatch[1] === 'x';
    const description = subtaskMatch[2].trim();

    if (!description.startsWith('Location:')) {
      subtasks.push({
        description,
        completed
      });
    }
  }

  const locationMatch = taskContent.match(/- Location: (.+)/);
  const location = locationMatch ? locationMatch[1].trim() : '';

  const allCompleted = subtasks.length > 0 && subtasks.every(st => st.completed);
  const status = allCompleted ? 'completed' : 'pending';

  const task = {
    id: \`task-\${taskNum}\`,
    title: taskTitle,
    status,
    subtasks,
    location
  };

  if (status === 'completed') {
    const commitInfo = findTaskCompletionCommit(taskNum, taskTitle);
    if (commitInfo) {
      task.completedDate = commitInfo.date;
      task.completedCommit = commitInfo;
    }
  }

  tasks.push(task);
}

console.log(JSON.stringify(tasks, null, 2));
" > "$TASKS_OUTPUT"
fi

if ! git diff --quiet "$OUTPUT_FILE" "$METADATA_FILE" "$TASKS_OUTPUT"; then
  git add "$OUTPUT_FILE" "$METADATA_FILE" "$TASKS_OUTPUT"
  git commit -m "Update dev data files" --no-verify
fi

exit 0
